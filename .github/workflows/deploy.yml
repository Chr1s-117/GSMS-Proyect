name: Deploy GSMS to EC2 via SSM

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  id-token: write     # OIDC para asumir el rol de AWS
  contents: read

env:
  AWS_REGION: us-east-1
  # Ajusta estos valores a los de tu cuenta/bucket/prefix
  S3_BUCKET: gsms-artifacts-727529936291-use1
  S3_PREFIX: WebServer_GSMS_S3_GitHub
  RELEASES_PREFIX: releases
  SSM_PACKAGE_PARAM: /gsms/prod/app/package_url

  # Target principal por TAG (recomendado). Si no lo usas, deja vacío y define ASG_NAME.
  EC2_TARGET_TAG_KEY: App
  EC2_TARGET_TAG_VALUE: gsms-web

  # Alternativa de destino por ASG (fallback si no usas TAGS):
  ASG_NAME: asg-gsms-web

  # ARN del rol que asume GitHub (defínelo como Repo Variable o Secret)
  AWS_ROLE_ARN: ${{ vars.AWS_ROLE_ARN || secrets.AWS_ROLE_ARN }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configurar credenciales de AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Calcular SHA y RELEASE_URI
        id: meta
        shell: bash
        run: |
          SHA="${GITHUB_SHA}"
          # Opcional: usar versión corta para el folder (comenta si quieres el hash completo)
          # SHA="$(echo "${GITHUB_SHA}" | cut -c1-12)"
          RELEASE_URI="s3://${S3_BUCKET}/${S3_PREFIX}/${RELEASES_PREFIX}/${SHA}"
          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          echo "release_uri=${RELEASE_URI}" >> $GITHUB_OUTPUT
          echo "Publicaremos en: ${RELEASE_URI}"

      - name: Publicar release en S3 (código del repo)
        shell: bash
        run: |
          set -euo pipefail
          aws s3 sync . "${{ steps.meta.outputs.release_uri }}" \
            --delete \
            --no-progress \
            --exclude ".git/*" \
            --exclude ".github/*"

      - name: Actualizar parámetro SSM con la release publicada
        shell: bash
        run: |
          set -euo pipefail
          aws ssm put-parameter \
            --name "${SSM_PACKAGE_PARAM}" \
            --type String \
            --overwrite \
            --value "${{ steps.meta.outputs.release_uri }}"
          echo "SSM ${SSM_PACKAGE_PARAM} -> ${{ steps.meta.outputs.release_uri }}"

      - name: Resolver INSTANCE_IDS del destino (por TAG o por ASG)
        id: targets
        shell: bash
        run: |
          set -euo pipefail

          INSTANCE_IDS=""
          if [[ -n "${EC2_TARGET_TAG_KEY}" && -n "${EC2_TARGET_TAG_VALUE}" ]]; then
            echo "Descubriendo instancias por Tag: ${EC2_TARGET_TAG_KEY}=${EC2_TARGET_TAG_VALUE}"
            INSTANCE_IDS="$(aws ec2 describe-instances \
              --filters "Name=instance-state-name,Values=running" "Name=tag:${EC2_TARGET_TAG_KEY},Values=${EC2_TARGET_TAG_VALUE}" \
              --query "Reservations[].Instances[].InstanceId" --output text | tr '\t' ',' | sed 's/,$//')"
          fi

          if [[ -z "${INSTANCE_IDS}" && -n "${ASG_NAME}" ]]; then
            echo "Descubriendo instancias por ASG: ${ASG_NAME}"
            INSTANCE_IDS="$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "${ASG_NAME}" \
              --query "AutoScalingGroups[0].Instances[?LifecycleState=='InService'].InstanceId" \
              --output text | tr '\t' ',' | sed 's/,$//')"
          fi

          if [[ -z "${INSTANCE_IDS}" ]]; then
            echo "Error: No se encontraron instancias destino." >&2
            exit 1
          fi

          echo "instance_ids=${INSTANCE_IDS}" >> $GITHUB_OUTPUT
          echo "Instancias: ${INSTANCE_IDS}"

      - name: Pre-chequeo: asegurar que existe /usr/local/bin/deploy_from_s3.sh
        id: precheck
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"

          echo "Ejecutando prechequeo en instancias: ${{ steps.targets.outputs.instance_ids }}"
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${IDS[@]}" \
            --document-name "AWS-RunShellScript" \
            --comment "Precheck deploy script" \
            --parameters '{"commands":["if [ -x /usr/local/bin/deploy_from_s3.sh ]; then echo OK; else echo MISSING; exit 42; fi"]}' \
            --query "Command.CommandId" --output text)

          echo "cmd_id=${CMD_ID}" >> $GITHUB_OUTPUT

          # Esperar a que terminen todas con polling simple
          FAIL=0
          for id in "${IDS[@]}"; do
            echo "Esperando precheck en $id ..."
            for i in {1..20}; do
              STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" --query "Status" --output text || echo "Unknown")
              [[ "$STATUS" == "Success" ]] && break
              [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]] && { FAIL=1; break; }
              sleep 6
            done
          done

          if [[ $FAIL -ne 0 ]]; then
            echo "precheck_result=missing" >> $GITHUB_OUTPUT
            echo "Precheck: faltan scripts en alguna(s) instancia(s)."
          else
            echo "precheck_result=ok" >> $GITHUB_OUTPUT
            echo "Precheck OK en todas las instancias."
          fi


      - name: Hacer ejecutable el fix y ejecutarlo si falta el script
        if: steps.precheck.outputs.precheck_result == 'missing'
        shell: bash
        run: |
          set -euo pipefail
          chmod +x .github/scripts/fix_ssm.sh
          export INSTANCE_IDS="${{ steps.targets.outputs.instance_ids }}"
          export RELEASE_URI="${{ steps.meta.outputs.release_uri }}"
          NEW_CMD_ID=$(bash .github/scripts/fix_ssm.sh)
          echo "Fix lanzado. CommandId: ${NEW_CMD_ID}"

      - name: Desplegar release en EC2 vía SSM
        id: deploy
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"

          echo "Enviando deploy a: ${{ steps.targets.outputs.instance_ids }}"
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${IDS[@]}" \
            --document-name "AWS-RunShellScript" \
            --comment "GSMS Deploy ${GITHUB_SHA}" \
            --parameters "{\"commands\":[\"sudo bash -lc \\\"/usr/local/bin/deploy_from_s3.sh '${{ steps.meta.outputs.release_uri }}'\\\"\"]}" \
            --query "Command.CommandId" --output text)

          echo "cmd_id=${CMD_ID}" >> $GITHUB_OUTPUT
          echo "CommandId: ${CMD_ID}"

      - name: Esperar y verificar despliegue SSM
        shell: bash
        run: |
          set -euo pipefail
          CMD_ID="${{ steps.deploy.outputs.cmd_id }}"
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"
          FAIL=0

          for id in "${IDS[@]}"; do
            echo "Esperando resultado en $id ..."
            for i in {1..40}; do
              OUT=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" || true)
              STATUS=$(echo "$OUT" | jq -r '.Status // "Unknown"')
              if [[ "$STATUS" == "Success" ]]; then
                echo "OK $id"
                break
              fi
              if [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
                echo "Fallo en $id, status=$STATUS"
                echo "$OUT"
                FAIL=1
                break
              fi
              sleep 6
            done
          done

          if [[ $FAIL -ne 0 ]]; then
            echo "ERROR: Alguna instancia falló en el despliegue."
            exit 1
          fi

      - name: Fin
        run: echo "Despliegue completado correctamente en todas las instancias."
