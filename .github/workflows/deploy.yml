name: Deploy (main) - S3 first, then EC2

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      release_sha:
        description: "SHA a desplegar (rollback)"
        required: false

concurrency:
  group: prod-deploy
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read
  deployments: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Who am I? (Diagnostic)
        run: aws sts get-caller-identity

      - name: Determinar SHA
        id: picksha
        run: |
          if [ -n "${{ github.event.inputs.release_sha }}" ]; then
            echo "SHA=${{ github.event.inputs.release_sha }}" >> $GITHUB_OUTPUT
          else
            echo "SHA=${GITHUB_SHA}" >> $GITHUB_OUTPUT
          fi

      - name: Sync frontend
        run: |
          if [ -d "front" ]; then
            aws s3 sync ./front s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/front --delete
          else
            echo "No hay carpeta front/, se omite"
          fi

      - name: Publicar release
        run: |
          DEST="s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/releases/${{ steps.picksha.outputs.SHA }}"
          aws s3 sync . "$DEST" --delete --exclude ".git/*" --exclude ".github/*"

      - name: Actualizar parámetro package_url (SSM)
        run: |
          aws ssm put-parameter \
            --name "/gsms/prod/app/package_url" \
            --type String \
            --value "s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/releases/${{ steps.picksha.outputs.SHA }}" \
            --overwrite

      - name: Deploy via SSM (send command)
        id: send_ssm_command
        env:
          RELEASE_URI: s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/releases/${{ steps.picksha.outputs.SHA }}
        run: |
          if [ -z "${{ vars.AWS_REGION }}" ]; then
            echo "Error: AWS_REGION no definido"
            exit 1
          fi
          if [ -n "${{ vars.EC2_INSTANCE_IDS }}" ]; then
            INSTANCE_IDS_CLEAN="$(echo "${{ vars.EC2_INSTANCE_IDS }}" | tr ',' ' ' | xargs)"
            TARGET="--instance-ids $INSTANCE_IDS_CLEAN"
          else
            if [ -z "${{ vars.EC2_TARGET_TAG_KEY }}" ] || [ -z "${{ vars.EC2_TARGET_TAG_VALUE }}" ]; then
              echo "Error: EC2_TARGET_TAG_KEY o EC2_TARGET_TAG_VALUE no definidos"
              exit 1
            fi
            TARGET="--targets Key=tag:${{ vars.EC2_TARGET_TAG_KEY }},Values=${{ vars.EC2_TARGET_TAG_VALUE }}"
          fi
          
          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy ${{ steps.picksha.outputs.SHA }}" \
            --parameters '{"commands":["sudo bash -lc \"/usr/local/bin/deploy_from_s3.sh '"${RELEASE_URI}"'\""]}' \
            $TARGET \
            --query 'Command.CommandId' --output text)

          echo "CMD_ID=$CMD_ID" >> $GITHUB_OUTPUT
          echo "Comando enviado a SSM. CommandId: $CMD_ID"

      - name: Esperar y Verificar Despliegue SSM
        env:
          CMD_ID: ${{ steps.send_ssm_command.outputs.CMD_ID }}
          ASG_NAME: ${{ vars.ASG_NAME }}
          RELEASE_URI: s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/releases/${{ steps.picksha.outputs.SHA }}
          SHA: ${{ steps.picksha.outputs.SHA }}
        run: |
          set -e
          if [ -z "$ASG_NAME" ]; then
            echo "Error: ASG_NAME no definido"
            exit 1
          fi
          echo "Esperando invocaciones para el CommandId: $CMD_ID..."
          for i in {1..60}; do
            COUNT=$(aws ssm list-command-invocations --command-id "$CMD_ID" --query 'length(CommandInvocations)' --output text)
            [ "$COUNT" -gt 0 ] && break
            echo "Aún no hay invocaciones... esperando 5s"
            sleep 5
          done
          
          echo "Invocación encontrada. Esperando estado 'Success'..."
          for i in {1..240}; do
            BAD_STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[?Status==`Failed` || Status==`TimedOut` || Status==`Cancelled`]' --output json)
            if [ "$BAD_STATUS" != "[]" ]; then
              echo "Error: Una o más instancias fallaron el despliegue."
              aws ssm list-command-invocations --command-id "$CMD_ID" --details
              
              echo "Intentando fix: Obteniendo IDs de instancias del ASG..."
              INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" --query "AutoScalingGroups[0].Instances[].InstanceId" --output text | tr '\t' ',' | sed 's/,$//')
              if [ -z "$INSTANCE_IDS" ]; then
                echo "Error: No se encontraron instancias en el ASG $ASG_NAME."
                exit 1
              fi
              
              # Llama al script separado y captura nuevo CMD_ID
              NEW_CMD_ID=$(bash scripts/fix_ssm.sh)
              
              if [ -z "$NEW_CMD_ID" ]; then
                echo "Error en fix script"
                exit 1
              fi
              CMD_ID="$NEW_CMD_ID"  # Actualiza CMD_ID para continuar verificación
              continue
            fi
            
            PENDING_STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[?Status!=`Success` && Status!=`InProgress` && Status!=`Pending`]' --output json)
            if [ "$PENDING_STATUS" = "[]" ]; then
              echo "¡Éxito! Todas las instancias completaron el despliegue."
              exit 0
            fi
            
            echo "Despliegue en progreso... esperando 5s"
            sleep 5
          done
          
          echo "Error: Timeout esperando el estado 'Success' después de 20 minutos."
          aws ssm list-command-invocations --command-id "$CMD_ID" --details
          exit 1