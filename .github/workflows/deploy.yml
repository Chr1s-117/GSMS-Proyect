name: Deploy (main) - S3 first, then EC2

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      release_sha:
        description: "SHA a desplegar (rollback)"
        required: false

concurrency:
  group: prod-deploy
  cancel-in-progress: false

# Permisos mínimos necesarios para OIDC y despliegues
permissions:
  id-token: write
  contents: read
  deployments: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Who am I? (Diagnostic)
        run: aws sts get-caller-identity

      - name: Determinar SHA
        id: picksha
        run: |
          if [ -n "${{ github.event.inputs.release_sha }}" ]; then
            echo "SHA=${{ github.event.inputs.release_sha }}" >> $GITHUB_OUTPUT
          else
            echo "SHA=${GITHUB_SHA}" >> $GITHUB_OUTPUT
          fi

      - name: Sync frontend
        run: |
          if [ -d "front" ]; then
            aws s3 sync ./front s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/front --delete
          else
            echo "No hay carpeta front/, se omite"
          fi

      - name: Publicar release
        run: |
          DEST="s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/releases/${{ steps.picksha.outputs.SHA }}"
          aws s3 sync . "$DEST" --delete --exclude ".git/*" --exclude ".github/*"

      - name: Actualizar parámetro package_url (SSM)
        run: |
          aws ssm put-parameter \
            --name "/gsms/prod/app/package_url" \
            --type String \
            --value "s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/releases/${{ steps.picksha.outputs.SHA }}" \
            --overwrite

      - name: Deploy via SSM (send command)
        id: send_ssm_command
        env:
          RELEASE_URI: s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/releases/${{ steps.picksha.outputs.SHA }}
        run: |
          if [ -n "${{ vars.EC2_INSTANCE_IDS }}" ]; then
            TARGET="--instance-ids $(echo ${{ vars.EC2_INSTANCE_IDS }} | tr -d ' ')"
          else
            TARGET="--targets Key=tag:${{ vars.EC2_TARGET_TAG_KEY }},Values=${{ vars.EC2_TARGET_TAG_VALUE }}"
          fi
          
          # Se guarda el CommandId para el siguiente paso
          CMD_ID=$(aws ssm send-command \
            --document-name "arn:aws:ssm:us-east-1::document/AWS-RunShellScript" \
            --comment "Deploy ${{ steps.picksha.outputs.SHA }}" \
            --parameters commands="['sudo bash -lc \"/usr/local/bin/deploy_from_s3.sh ${RELEASE_URI}\"']" \
            $TARGET \
            --query 'Command.CommandId' --output text)

          echo "CMD_ID=$CMD_ID" >> $GITHUB_OUTPUT
          echo "Comando enviado a SSM. CommandId: $CMD_ID"

      - name: Esperar y Verificar Despliegue SSM
        env:
          CMD_ID: ${{ steps.send_ssm_command.outputs.CMD_ID }}
          ASG_NAME: ${{ vars.ASG_NAME }}
        run: |
          set -e
          echo "Esperando invocaciones para el CommandId: $CMD_ID..."
          for i in {1..30}; do
            COUNT=$(aws ssm list-command-invocations --command-id "$CMD_ID" --query 'length(CommandInvocations)' --output text)
            [ "$COUNT" -gt 0 ] && break
            echo "Aún no hay invocaciones... esperando 5s"
            sleep 5
          done
          
          echo "Invocación encontrada. Esperando estado 'Success'..."
          for i in {1..120}; do
            BAD_STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[?Status==`Failed` || Status==`TimedOut` || Status==`Cancelled`]' --output json)
            if [ "$BAD_STATUS" != "[]" ]; then
              echo "Error: Una o más instancias fallaron el despliegue."
              aws ssm list-command-invocations --command-id "$CMD_ID" --details
              
              # Fallback: Obtener IDs dinámicos del ASG y enviar comando para recrear script si missing
              echo "Intentando fix: Obteniendo IDs de instancias del ASG..."
              INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" --query "AutoScalingGroups[0].Instances[].InstanceId" --output text | tr '\t' ',' | sed 's/,$//')
              if [ -z "$INSTANCE_IDS" ]; then
                echo "Error: No se encontraron instancias en el ASG $ASG_NAME."
                exit 1
              fi
              
              echo "Enviando comando SSM para verificar/crear deploy_from_s3.sh en instancias: $INSTANCE_IDS"
              FIX_CMD_ID=$(aws ssm send-command \
                --document-name "AWS-RunShellScript" \
                --targets "Key=instanceids,Values=$INSTANCE_IDS" \
                --parameters '{
                  "commands": [
                    "if [ ! -f /usr/local/bin/deploy_from_s3.sh ]; then",
                    "  echo \"[FIX] Creando /usr/local/bin/deploy_from_s3.sh...\";",
                    "  cat <<\"EOF\" >/usr/local/bin/deploy_from_s3.sh",
                    "#!/usr/bin/env bash",
                    "set -euo pipefail",
                    "",
                    "# ====== Configuración (consistente con User Data) ======",
                    "REGION=\"${AWS_DEFAULT_REGION:-us-east-1}\"",
                    "APP_ROOT=\"/opt/gsms\"",
                    "APP_DIR=\"${APP_ROOT}/app\"",
                    "VENV_DIR=\"${APP_ROOT}/venv\"",
                    "SERVICE_WEB=\"gsms-web.service\"",
                    "SERVICE_UDP=\"gsms-udp.service\"",
                    "USER_SVC=\"gsms\"",
                    "",
                    "S3_PATH=\"${1:?Uso: deploy_from_s3.sh s3://bucket/prefix/release_id}\"",
                    "",
                    "# ====== Pre-chequeos ======",
                    "command -v aws >/dev/null || { echo \"Falta AWS CLI\"; exit 20; }",
                    "install -d -o \"${USER_SVC}\" -g \"${USER_SVC}\" -m 0755 \"${APP_DIR}/src\"",
                    "",
                    "# Chequeo adicional: Verifica si venv está inicializado",
                    "if [ ! -f \"${VENV_DIR}/bin/pip\" ]; then",
                    "  echo \"[ERROR] Venv no inicializado correctamente. Saliendo.\"",
                    "  exit 1",
                    "fi",
                    "",
                    "# ====== Sincronización de Código ======",
                    "echo \"[Deploy] Sincronizando código desde ${S3_PATH}\"",
                    "aws s3 sync \"${S3_PATH%/}/src/\" \"${APP_DIR}/src/\" --delete --exclude \".git/*\" || true",
                    "aws s3 sync \"${S3_PATH%/}/\" \"${APP_DIR}/\" --delete --exclude \"src/*\" --exclude \"releases/*\" --exclude \".git/*\" || true",
                    "",
                    "chown -R ${USER_SVC}:${USER_SVC} \"${APP_DIR}\"",
                    "find \"${APP_DIR}\" -type d -name \"__pycache__\" -exec rm -rf {} + || true",
                    "",
                    "# ====== Instalación Inteligente de Dependencias ======",
                    "REQ_FILE=\"\"",
                    "[ -f \"${APP_DIR}/requirements.txt\" ] && REQ_FILE=\"${APP_DIR}/requirements.txt\"",
                    "[ -z \"$REQ_FILE\" ] && [ -f \"${APP_DIR}/src/requirements.txt\" ] && REQ_FILE=\"${APP_DIR}/src/requirements.txt\"",
                    "",
                    "if [ -n \"$REQ_FILE\" ]; then",
                    "  CURR_SHA=\"$(sha256sum \"$REQ_FILE\" | awk '{print $1}')\"",
                    "  PREV_SHA_FILE=\"${APP_ROOT}/.requirements.sha256\"",
                    "  PREV_SHA=\"$(cat \"$PREV_SHA_FILE\" 2>/dev/null || echo \"\")\"",
                    "  if [ \"$CURR_SHA\" != \"$PREV_SHA\" ]; then",
                    "    echo \"[Deps] Cambios en requirements -> instalando...\"",
                    "    \"${VENV_DIR}/bin/pip\" install --upgrade pip wheel",
                    "    \"${VENV_DIR}/bin/pip\" install -r \"$REQ_FILE\"",
                    "    echo \"$CURR_SHA\" | tee \"$PREV_SHA_FILE\" >/dev/null",
                    "  else",
                    "    echo \"[Deps] Requirements sin cambios, se omite instalación.\"",
                    "  fi",
                    "else",
                    "  echo \"[Deps] No se encontró requirements.txt. Instalando dependencias base...\"",
                    "  \"${VENV_DIR}/bin/pip\" install --upgrade pip wheel",
                    "  \"${VENV_DIR}/bin/pip\" install fastapi==0.116.1 uvicorn[standard]==0.35.0 SQLAlchemy==2.0.43 alembic==1.16.5 psycopg2-binary==2.9.10 aiosqlite==0.20.0 pydantic==2.11.7 pydantic-settings==2.1.0 requests==2.31.0 Jinja2==3.1.3",
                    "fi",
                    "",
                    "# Chequeo post-instalación: Verifica si uvicorn y pydantic-settings están instalados",
                    "if [ ! -f \"${VENV_DIR}/bin/uvicorn\" ] || ! \"${VENV_DIR}/bin/pip\" list | grep -q pydantic-settings; then",
                    "  echo \"[ERROR] Uvicorn o pydantic-settings no instalado. Dependencias fallaron.\"",
                    "  exit 1",
                    "fi",
                    "",
                    "# ====== Reinicio de Servicios ======",
                    "echo \"[Deploy] Reiniciando servicios...\"",
                    "systemctl daemon-reload",
                    "if systemctl list-unit-files | grep -q \"^${SERVICE_WEB}\"; then",
                    "  systemctl restart \"${SERVICE_WEB}\"",
                    "  sleep 2",
                    "  systemctl --no-pager --full status \"${SERVICE_WEB}\" | tail -n 50 || true",
                    "fi",
                    "if systemctl list-unit-files | grep -q \"^${SERVICE_UDP}\"; then",
                    "  systemctl restart \"${SERVICE_UDP}\" || true",
                    "  systemctl --no-pager --full status \"${SERVICE_UDP}\" | tail -n 30 || true",
                    "fi",
                    "",
                    "# ====== Verificación y Marca de Versión ======",
                    "echo \"release=$(basename \"${S3_PATH}\")\" | tee ${APP_ROOT}/build.txt >/dev/null",
                    "curl -sS --max-time 3 http://127.0.0.1:8000/health || echo \"[WARN] /health no respondió.\"",
                    "echo \"[Deploy] OK\"",
                    "EOF",
                    "  chmod +x /usr/local/bin/deploy_from_s3.sh",
                    "  sed -i 's/\r$//' /usr/local/bin/deploy_from_s3.sh",
                    "  echo \"Script recreado.\";",
                    "else",
                    "  echo \"Script ya existe.\";",
                    "fi"
                  ]
                }' \
                --query "Command.CommandId" --output text)
              
              # Espera el fix (similar bucle, simplificado aquí)
              for j in {1..60}; do
                FIX_STATUS=$(aws ssm list-command-invocations --command-id "$FIX_CMD_ID" --details --query 'CommandInvocations[?Status!=`Success`]' --output json)
                if [ "$FIX_STATUS" = "[]" ]; then
                  echo "Fix completado. Reintentando deploy original..."
                  # Re-envía el comando original aquí si quieres retry automático
                  # Por ejemplo:
                  # ORIGINAL_CMD_ID=$(aws ssm send-command ... )  # Copia el comando de deploy original
                  # Luego actualiza CMD_ID=$ORIGINAL_CMD_ID y continúa el loop o reinicia la verificación
                  break
                fi
                sleep 5
              done
              exit 1  # Exit por ahora; quita si quieres retry automático completo
            fi
            
            PENDING_STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[?Status!=`Success`]' --output json)
            if [ "$PENDING_STATUS" = "[]" ]; then
              echo "¡Éxito! Todas las instancias completaron el despliegue."
              exit 0
            fi
            
            echo "Despliegue en progreso... esperando 5s"
            sleep 5
          done
          
          echo "Error: Timeout esperando el estado 'Success' después de 10 minutos."
          aws ssm list-command-invocations --command-id "$CMD_ID" --details
          exit 1