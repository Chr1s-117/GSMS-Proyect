name: Deploy (main) - S3 first, then EC2

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      release_sha:
        description: "SHA a desplegar (rollback)"
        required: false

concurrency:
  group: prod-deploy
  cancel-in-progress: false

# Permisos mínimos necesarios para OIDC y despliegues
permissions:
  id-token: write
  contents: read
  deployments: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Who am I? (Diagnostic)
        run: aws sts get-caller-identity

      - name: Determinar SHA
        id: picksha
        run: |
          if [ -n "${{ github.event.inputs.release_sha }}" ]; then
            echo "SHA=${{ github.event.inputs.release_sha }}" >> $GITHUB_OUTPUT
          else
            echo "SHA=${GITHUB_SHA}" >> $GITHUB_OUTPUT
          fi

      - name: Sync frontend
        run: |
          if [ -d "front" ]; then
            aws s3 sync ./front s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/front --delete
          else
            echo "No hay carpeta front/, se omite"
          fi

      - name: Publicar release
        run: |
          DEST="s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/releases/${{ steps.picksha.outputs.SHA }}"
          aws s3 sync . "$DEST" --delete --exclude ".git/*" --exclude ".github/*"

      - name: Actualizar parámetro package_url (SSM)
        run: |
          aws ssm put-parameter \
            --name "/gsms/prod/app/package_url" \
            --type String \
            --value "s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/releases/${{ steps.picksha.outputs.SHA }}" \
            --overwrite

      - name: Deploy via SSM (send command)
        id: send_ssm_command
        env:
          RELEASE_URI: s3://${{ vars.S3_BUCKET }}/${{ vars.S3_PREFIX }}/releases/${{ steps.picksha.outputs.SHA }}
        run: |
          if [ -n "${{ vars.EC2_INSTANCE_IDS }}" ]; then
            TARGET="--instance-ids $(echo ${{ vars.EC2_INSTANCE_IDS }} | tr -d ' ')"
          else
            TARGET="--targets Key=tag:${{ vars.EC2_TARGET_TAG_KEY }},Values=${{ vars.EC2_TARGET_TAG_VALUE }}"
          fi
          
          # Se guarda el CommandId para el siguiente paso
          CMD_ID=$(aws ssm send-command \
            --document-name "arn:aws:ssm:us-east-1::document/AWS-RunShellScript" \
            --comment "Deploy ${{ steps.picksha.outputs.SHA }}" \
            --parameters commands="['sudo bash -lc \"/usr/local/bin/deploy_from_s3.sh ${RELEASE_URI}\"']" \
            $TARGET \
            --query 'Command.CommandId' --output text)

          echo "CMD_ID=$CMD_ID" >> $GITHUB_OUTPUT
          echo "Comando enviado a SSM. CommandId: $CMD_ID"

      - name: Esperar y Verificar Despliegue SSM
        env:
          CMD_ID: ${{ steps.send_ssm_command.outputs.CMD_ID }}
          ASG_NAME: ${{ vars.ASG_NAME }}
        run: |
          set -e
          echo "Esperando invocaciones para el CommandId: $CMD_ID..."
          for i in {1..30}; do
            COUNT=$(aws ssm list-command-invocations --command-id "$CMD_ID" --query 'length(CommandInvocations)' --output text)
            [ "$COUNT" -gt 0 ] && break
            echo "Aún no hay invocaciones... esperando 5s"
            sleep 5
          done
          
          echo "Invocación encontrada. Esperando estado 'Success'..."
          for i in {1..120}; do
            BAD_STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[?Status==`Failed` || Status==`TimedOut` || Status==`Cancelled`]' --output json)
            if [ "$BAD_STATUS" != "[]" ]; then
              echo "Error: Una o más instancias fallaron el despliegue."
              aws ssm list-command-invocations --command-id "$CMD_ID" --details
              
              # Fallback: Obtener IDs dinámicos del ASG y enviar comando para recrear script si missing
              echo "Intentando fix: Obteniendo IDs de instancias del ASG..."
              INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" --query "AutoScalingGroups[0].Instances[].InstanceId" --output text | tr '\n' ',' | sed 's/,$//')
              if [ -z "$INSTANCE_IDS" ]; then
                echo "Error: No se encontraron instancias en el ASG $ASG_NAME."
                exit 1
              fi
              
              echo "Enviando comando SSM para verificar/crear deploy_from_s3.sh en instancias: $INSTANCE_IDS"
              FIX_CMD_ID=$(aws ssm send-command --document-name "AWS-RunShellScript" --targets "Key=instanceids,Values=$INSTANCE_IDS" \
                --parameters '{"commands":["if [ ! -f /usr/local/bin/deploy_from_s3.sh ]; then echo \"[FIX] Creando /usr/local/bin/deploy_from_s3.sh...\"; tee /usr/local/bin/deploy_from_s3.sh >/dev/null <<\"EOF\"\n#!/usr/bin/env bash\nset -euo pipefail\n\n# ====== Configuración (consistente con User Data) ======\nREGION=\"${AWS_DEFAULT_REGION:-us-east-1}\"\nAPP_ROOT=\"/opt/gsms\"\nAPP_DIR=\"${APP_ROOT}/app\"\nVENV_DIR=\"${APP_ROOT}/venv\"\nSERVICE_WEB=\"gsms-web.service\"\nSERVICE_UDP=\"gsms-udp.service\"\nUSER_SVC=\"gsms\"\n\nS3_PATH=\"${1:?Uso: deploy_from_s3.sh s3://bucket/prefix/release_id}\"\n\n# ====== Pre-chequeos ======\ncommand -v aws >/dev/null || { echo \"Falta AWS CLI\"; exit 20; }\ninstall -d -o \"${USER_SVC}\" -g \"${USER_SVC}\" -m 0755 \"${APP_DIR}/src\"\n\n# Chequeo adicional: Verifica si venv está inicializado\nif [ ! -f \"${VENV_DIR}/bin/pip\" ]; then\n  echo \"[ERROR] Venv no inicializado correctamente. Saliendo.\"\n  exit 1\nfi\n\n# ====== Sincronización de Código ======\necho \"[Deploy] Sincronizando código desde ${S3_PATH}\"\naws s3 sync \"${S3_PATH%/}/src/\" \"${APP_DIR}/src/\" --delete --exclude \".git/*\" || true\naws s3 sync \"${S3_PATH%/}/\" \"${APP_DIR}/\" --delete --exclude \"src/*\" --exclude \"releases/*\" --exclude \".git/*\" || true\n\nchown -R ${USER_SVC}:${USER_SVC} \"${APP_DIR}\"\nfind \"${APP_DIR}\" -type d -name \"__pycache__\" -exec rm -rf {} + || true\n\n# ====== Instalación Inteligente de Dependencias ======\nREQ_FILE=\"\"\n[ -f \"${APP_DIR}/requirements.txt\" ] && REQ_FILE=\"${APP_DIR}/requirements.txt\"\n[ -z \"$REQ_FILE\" ] && [ -f \"${APP_DIR}/src/requirements.txt\" ] && REQ_FILE=\"${APP_DIR}/src/requirements.txt\"\n\nif [ -n \"$REQ_FILE\" ]; then\n  CURR_SHA=\"$(sha256sum \"$REQ_FILE\" | awk '{print $1}')\"\n  PREV_SHA_FILE=\"${APP_ROOT}/.requirements.sha256\"\n  PREV_SHA=\"$(cat \"$PREV_SHA_FILE\" 2>/dev/null || echo \"\")\"\n  if [ \"$CURR_SHA\" != \"$PREV_SHA\" ]; then\n    echo \"[Deps] Cambios en requirements -> instalando...\"\n    \"${VENV_DIR}/bin/pip\" install --upgrade pip wheel\n    \"${VENV_DIR}/bin/pip\" install -r \"$REQ_FILE\"\n    echo \"$CURR_SHA\" | tee \"$PREV_SHA_FILE\" >/dev/null\n  else\n    echo \"[Deps] Requirements sin cambios, se omite instalación.\"\n  fi\nelse\n  echo \"[Deps] No se encontró requirements.txt. Instalando dependencias base...\"\n  \"${VENV_DIR}/bin/pip\" install --upgrade pip wheel\n  \"${VENV_DIR}/bin/pip\" install fastapi==0.116.1 uvicorn[standard]==0.35.0 SQLAlchemy==2.0.43 alembic==1.16.5 psycopg2-binary==2.9.10 aiosqlite==0.20.0 pydantic==2.11.7 pydantic-settings==2.1.0 requests==2.31.0 Jinja2==3.1.3\nfi\n\n# Chequeo post-instalación: Verifica si uvicorn y pydantic-settings están instalados\nif [ ! -f \"${VENV_DIR}/bin/uvicorn\" ] || ! \"${VENV_DIR}/bin/pip\" list | grep -q pydantic-settings; then\n  echo \"[ERROR] Uvicorn o pydantic-settings no instalado. Dependencias fallaron.\"\n  exit 1\nfi\n\n# ====== Reinicio de Servicios ======\necho \"[Deploy] Reiniciando servicios...\"\nsystemctl daemon-reload\nif systemctl list-unit-files | grep -q \"^${SERVICE_WEB}\"; then\n  systemctl restart \"${SERVICE_WEB}\"\n  sleep 2\n  systemctl --no-pager --full status \"${SERVICE_WEB}\" | tail -n 50 || true\nfi\nif systemctl list-unit-files | grep -q \"^${SERVICE_UDP}\"; then\n  systemctl restart \"${SERVICE_UDP}\" || true\n  systemctl --no-pager --full status \"${SERVICE_UDP}\" | tail -n 30 || true\nfi\n\n# ====== Verificación y Marca de Versión ======\necho \"release=$(basename \"${S3_PATH}\")\" | tee ${APP_ROOT}/build.txt >/dev/null\ncurl -sS --max-time 3 http://127.0.0.1:8000/health || echo \"[WARN] /health no respondió.\"\necho \"[Deploy] OK\"\nEOF\nchmod +x /usr/local/bin/deploy_from_s3.sh\nsed -i 's/\r$//' /usr/local/bin/deploy_from_s3.sh\necho \"Script recreado.\"; else echo \"Script ya existe.\"; fi"]}' \
                --query "Command.CommandId" --output text)
              
              # Espera el fix (similar bucle, simplificado aquí)
              for j in {1..60}; do
                FIX_STATUS=$(aws ssm list-command-invocations --command-id "$FIX_CMD_ID" --details --query 'CommandInvocations[?Status!=`Success`]' --output json)
                if [ "$FIX_STATUS" = "[]" ]; then
                  echo "Fix completado. Reintentando deploy original..."
                  # Re-envía el comando original aquí si quieres retry automático
                  break
                fi
                sleep 5
              done
              exit 1  # Exit por ahora; quita si quieres retry
            fi
            
            PENDING_STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[?Status!=`Success`]' --output json)
            if [ "$PENDING_STATUS" = "[]" ]; then
              echo "¡Éxito! Todas las instancias completaron el despliegue."
              exit 0
            fi
            
            echo "Despliegue en progreso... esperando 5s"
            sleep 5
          done
          
          echo "Error: Timeout esperando el estado 'Success' después de 10 minutos."
          aws ssm list-command-invocations --command-id "$CMD_ID" --details
          exit 1