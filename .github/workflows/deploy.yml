name: Deploy GSMS to EC2 via SSM

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  id-token: write     # OIDC para asumir el rol de AWS
  contents: read

env:
  AWS_REGION: us-east-1
  # Ajusta estos valores a los de tu cuenta/bucket/prefix
  S3_BUCKET: gsms-artifacts-727529936291-use1
  S3_PREFIX: WebServer_GSMS_S3_GitHub
  RELEASES_PREFIX: releases
  SSM_PACKAGE_PARAM: /gsms/prod/app/package_url

  # Target principal por TAG (recomendado). Si no lo usas, deja vacío y define ASG_NAME.
  EC2_TARGET_TAG_KEY: App
  EC2_TARGET_TAG_VALUE: gsms-web

  # Alternativa de destino por ASG (fallback si no usas TAGS):
  ASG_NAME: asg-gsms-web

  # ARN del rol que asume GitHub (defínelo como Repo Variable o Secret)
  AWS_ROLE_ARN: ${{ vars.AWS_ROLE_ARN || secrets.AWS_ROLE_ARN }}

  # Controla si se reinician las instancias al final
  REBOOT_AFTER_DEPLOY: "true"

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare local deploy_from_s3.sh
        shell: bash
        run: |
          cat > deploy_from_s3.sh <<'EOF_SCRIPT'
          #!/usr/bin/env bash
          set -euo pipefail

          REGION="${AWS_DEFAULT_REGION:-us-east-1}"
          APP_ROOT="/opt/gsms"
          APP_DIR="${APP_ROOT}/app"
          VENV_DIR="${APP_ROOT}/venv"
          SERVICE_WEB="gsms-web.service"
          SERVICE_UDP="gsms-udp.service"
          USER_SVC="gsms"

          S3_PATH="${1:?Uso: deploy_from_s3.sh s3://bucket/prefix/release_id}"

          # Asegurar usuario/grupo o hacer fallback a root
          if ! id -u "${USER_SVC}" >/dev/null 2>&1; then
            echo "[WARN] Usuario ${USER_SVC} no existe; usando root para propietarios."
            USER_SVC="root"
          fi

          # Asegurar estructura y venv
          install -d -m 0755 "${APP_DIR}/src"
          chown -R ${USER_SVC}:${USER_SVC} "${APP_ROOT}" || true

          if [ ! -x "${VENV_DIR}/bin/python" ]; then
            echo "[Venv] Creando venv en ${VENV_DIR} ..."
            python3 -m venv "${VENV_DIR}"
          fi
          PY="${VENV_DIR}/bin/python"
          PIP="${VENV_DIR}/bin/pip"

          # ---- Chequeo fino de S3 (distingue sin-permisos vs. vacío) ----
          if ! aws s3 ls "${S3_PATH%/}/" --recursive >/tmp/gsms_ls.out 2>/tmp/gsms_ls.err ; then
            echo "[ERROR] Falló 'aws s3 ls' (posible permisos/red). Stderr:"
            sed -n '1,50p' /tmp/gsms_ls.err || true
            exit 22
          fi
          if ! grep -q . /tmp/gsms_ls.out ; then
            echo "[ERROR] Ruta S3 sin objetos: ${S3_PATH}"
            exit 21
          fi

          command -v aws >/dev/null || { echo "Falta AWS CLI"; exit 20; }

          # Menos ruido para no romper el pipe de SSM
          LOG_DIR="/var/log/gsms-deploy"
          install -d -m 0755 "${LOG_DIR}" || true

          echo "[Deploy] Sincronizando código desde ${S3_PATH}"
          aws s3 sync "${S3_PATH%/}/src/" "${APP_DIR}/src/" \
            --delete --exclude ".git/*" --no-progress --only-show-errors \
            > "${LOG_DIR}/s3_sync_src.log" 2>&1 || true
          echo "[s3] src sync (primeras 50 líneas)"; sed -n '1,50p' "${LOG_DIR}/s3_sync_src.log" || true

          aws s3 sync "${S3_PATH%/}/" "${APP_DIR}/" \
            --delete --exclude "src/*" --exclude "releases/*" --exclude ".git/*" \
            --no-progress --only-show-errors \
            > "${LOG_DIR}/s3_sync_root.log" 2>&1 || true
          echo "[s3] root sync (primeras 50 líneas)"; sed -n '1,50p' "${LOG_DIR}/s3_sync_root.log" || true

          chown -R ${USER_SVC}:${USER_SVC} "${APP_DIR}"
          find "${APP_DIR}" -type d -name "__pycache__" -exec rm -rf {} + || true

          REQ_FILE=""
          [ -f "${APP_DIR}/requirements.txt" ] && REQ_FILE="${APP_DIR}/requirements.txt"
          [ -z "$REQ_FILE" ] && [ -f "${APP_DIR}/src/requirements.txt" ] && REQ_FILE="${APP_DIR}/src/requirements.txt"

          # Siempre actualizar pip/wheel en silencio
          ${PY} -m pip install --upgrade --disable-pip-version-check -q pip wheel >> "${LOG_DIR}/pip_bootstrap.log" 2>&1 || true

          if [ -n "$REQ_FILE" ]; then
            CURR_SHA="$(sha256sum "$REQ_FILE" | awk '{print $1}')"
            PREV_SHA_FILE="${APP_ROOT}/.requirements.sha256"
            PREV_SHA="$(cat "$PREV_SHA_FILE" 2>/dev/null || echo "")"

            if [ "$CURR_SHA" != "$PREV_SHA" ]; then
              echo "[Deps] Cambios en requirements -> instalando..."
              ${PIP} install --no-input --disable-pip-version-check -r "$REQ_FILE" \
                >> "${LOG_DIR}/pip_install.log" 2>&1
              echo "$CURR_SHA" > "$PREV_SHA_FILE"
            else
              echo "[Deps] Requirements sin cambios."
            fi
          else
            echo "[Deps] No se encontró requirements.txt. Instalando base..."
            ${PIP} install --no-input --disable-pip-version-check \
              fastapi==0.116.1 "uvicorn[standard]"==0.35.0 SQLAlchemy==2.0.43 alembic==1.16.5 \
              psycopg2-binary==2.9.10 aiosqlite==0.20.0 pydantic==2.11.7 pydantic-settings==2.1.0 \
              requests==2.31.0 Jinja2==3.1.3 >> "${LOG_DIR}/pip_install.log" 2>&1
          fi

          # Mostrar solo resumen de pip
          echo "[pip] bootstrap (últimas 40 líneas)"; tail -n 40 "${LOG_DIR}/pip_bootstrap.log" 2>/dev/null || true
          echo "[pip] install   (últimas 80 líneas)"; tail -n 80 "${LOG_DIR}/pip_install.log" 2>/dev/null || true

          # Verificación clara de dependencias
          if [ ! -x "${VENV_DIR}/bin/uvicorn" ]; then
            echo "[ERROR] uvicorn no se instaló en ${VENV_DIR}/bin"; exit 1
          fi
          if ! ${PIP} show pydantic-settings >/dev/null 2>&1; then
            echo "[ERROR] pydantic-settings no está instalado"; exit 1
          fi

          echo "[Deploy] Reiniciando servicios..."
          systemctl daemon-reload
          if systemctl list-unit-files | grep -q "^${SERVICE_WEB}"; then
            systemctl restart "${SERVICE_WEB}"
            sleep 2
            systemctl --no-pager --full status "${SERVICE_WEB}" | tail -n 50 || true
          fi
          if systemctl list-unit-files | grep -q "^${SERVICE_UDP}"; then
            systemctl restart "${SERVICE_UDP}" || true
            systemctl --no-pager --full status "${SERVICE_UDP}" | tail -n 30 || true
          fi

          echo "release=$(basename "${S3_PATH}")" > ${APP_ROOT}/build.txt
          curl -sS --max-time 3 http://127.0.0.1:8000/health >/dev/null || echo "[WARN] /health no respondió."
          echo "[Deploy] OK"
          EOF_SCRIPT

      - name: Configurar credenciales de AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Calcular SHA y RELEASE_URI
        id: meta
        shell: bash
        run: |
          SHA="${GITHUB_SHA}"
          RELEASE_URI="s3://${S3_BUCKET}/${S3_PREFIX}/${RELEASES_PREFIX}/${SHA}"
          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          echo "release_uri=${RELEASE_URI}" >> $GITHUB_OUTPUT
          echo "Publicaremos en: ${RELEASE_URI}"

      - name: Publicar release en S3 (código del repo)
        shell: bash
        run: |
          set -euo pipefail
          aws s3 sync . "${{ steps.meta.outputs.release_uri }}" \
            --delete \
            --no-progress \
            --exclude ".git/*" \
            --exclude ".github/*"

      - name: Verificar que la release tenga contenido
        shell: bash
        run: |
          set -euo pipefail
          RELEASE_URI="${{ steps.meta.outputs.release_uri }}"
          echo "Listando contenido de ${RELEASE_URI}/ ..."
          aws s3 ls "${RELEASE_URI}/" --recursive --human-readable --summarize || true

          COUNT=$(aws s3 ls "${RELEASE_URI}/" --recursive | wc -l || echo 0)
          if [ "${COUNT}" -eq 0 ]; then
            echo "::error::La release en S3 está vacía: ${RELEASE_URI}/"
            echo "Diagnóstico local:"
            echo "== ls -la =="
            ls -la
            echo "== git ls-files (máx 200) =="
            git ls-files | head -n 200
            exit 66
          fi

      - name: Actualizar parámetro SSM con la release publicada
        shell: bash
        run: |
          set -euo pipefail
          aws ssm put-parameter \
            --name "${SSM_PACKAGE_PARAM}" \
            --type String \
            --overwrite \
            --value "${{ steps.meta.outputs.release_uri }}"
          echo "SSM ${SSM_PACKAGE_PARAM} -> ${{ steps.meta.outputs.release_uri }}"

      - name: Resolver INSTANCE_IDS del destino (por TAG o por ASG)
        id: targets
        shell: bash
        run: |
          set -euo pipefail

          INSTANCE_IDS=""
          if [[ -n "${EC2_TARGET_TAG_KEY}" && -n "${EC2_TARGET_TAG_VALUE}" ]]; then
            echo "Descubriendo instancias por Tag: ${EC2_TARGET_TAG_KEY}=${EC2_TARGET_TAG_VALUE}"
            INSTANCE_IDS="$(aws ec2 describe-instances \
              --filters "Name=instance-state-name,Values=running" "Name=tag:${EC2_TARGET_TAG_KEY},Values=${EC2_TARGET_TAG_VALUE}" \
              --query "Reservations[].Instances[].InstanceId" --output text | tr '\t' ',' | sed 's/,$//')"
          fi

          if [[ -z "${INSTANCE_IDS}" && -n "${ASG_NAME}" ]]; then
            echo "Descubriendo instancias por ASG: ${ASG_NAME}"
            INSTANCE_IDS="$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "${ASG_NAME}" \
              --query "AutoScalingGroups[0].Instances[?LifecycleState=='InService'].InstanceId" \
              --output text | tr '\t' ',' | sed 's/,$//')"
          fi

          if [[ -z "${INSTANCE_IDS}" ]]; then
            echo "Error: No se encontraron instancias destino." >&2
            exit 1
          fi

          echo "instance_ids=${INSTANCE_IDS}" >> $GITHUB_OUTPUT
          echo "Instancias: ${INSTANCE_IDS}"

      - name: Pre-chequeo del deploy script (existencia y hash)
        id: precheck
        shell: bash
        run: |
          set -eo pipefail
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"

          EXPECTED_SHA="$(sha256sum deploy_from_s3.sh | cut -d' ' -f1)"

          CMD_ID=$(aws ssm send-command \
            --instance-ids "${IDS[@]}" \
            --document-name "AWS-RunShellScript" \
            --parameters "{\"commands\":[
              \"set -e\",
              \"if [ -x /usr/local/bin/deploy_from_s3.sh ]; then sha256sum /usr/local/bin/deploy_from_s3.sh | cut -d' ' -f1; else echo MISSING; exit 42; fi\"
            ]}" \
            --query "Command.CommandId" --output text)

          MISMATCH=0
          for id in "${IDS[@]}"; do
            for i in {1..10}; do
              STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" --query "Status" --output text || echo Unknown)
              [[ "$STATUS" == "Success" || "$STATUS" == "Failed" || "$STATUS" == "TimedOut" || "$STATUS" == "Cancelled" ]] && break
              sleep 2
            done
            OUT=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" --query "StandardOutputContent" --output text || echo "")
            if [[ "$OUT" != "$EXPECTED_SHA" ]]; then
              echo "Mismatch/MISSING en $id ($OUT != $EXPECTED_SHA)"
              MISMATCH=1
            fi
          done

          if [[ $MISMATCH -ne 0 ]]; then
            echo "precheck_result=missing" >> $GITHUB_OUTPUT
          else
            echo "precheck_result=ok" >> $GITHUB_OUTPUT
          fi

      - name: Sincronizar/instalar deploy_from_s3.sh (idempotente)
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"
          B64="$(base64 -w0 deploy_from_s3.sh)"   # macOS: base64 -b 0

          CMD_ID=$(aws ssm send-command \
            --instance-ids "${IDS[@]}" \
            --document-name "AWS-RunShellScript" \
            --comment "Sync deploy_from_s3.sh (base64)" \
            --parameters "{\"commands\":[
              \"set -e\",
              \"echo '${B64}' | base64 -d > /usr/local/bin/deploy_from_s3.sh\",
              \"chmod +x /usr/local/bin/deploy_from_s3.sh\",
              \"sed -i 's/\\r$//' /usr/local/bin/deploy_from_s3.sh\",
              \"head -n 3 /usr/local/bin/deploy_from_s3.sh\"
            ]}" \
            --query "Command.CommandId" --output text)

          for id in "${IDS[@]}"; do
            for i in {1..20}; do
              STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" --query "Status" --output text || echo unknown)
              [[ "$STATUS" == "Success" || "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]] && break
              sleep 2
            done
            echo "--- Resultado sync en $id ---"
            aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" \
              --query "{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}" --output text || true
          done

      # NUEVO paso: Instalar/actualizar gsms-web.service (Uvicorn 0.0.0.0:8000)
      - name: Instalar/actualizar gsms-web.service (Uvicorn 0.0.0.0:8000)
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"

          # Construimos el unit y el drop-in en variables simples
          read -r -d '' UNIT <<'EOFU'
          [Unit]
          Description=GSMS Web API (Uvicorn)
          After=network-online.target
          Wants=network-online.target

          [Service]
          User=gsms
          Group=gsms
          WorkingDirectory=/opt/gsms/app
          EnvironmentFile=-/etc/systemd/system/gsms-web.service.d/env.conf
          Environment=PYTHONPATH=/opt/gsms/app

          # Preflight: venv y que src.main:app sea importable
          ExecStartPre=/bin/bash -lc 'test -x /opt/gsms/venv/bin/python'
          ExecStartPre=/opt/gsms/venv/bin/python -c "import sys; sys.path.insert(0,'/opt/gsms/app'); import importlib; m=importlib.import_module('src.main'); assert hasattr(m,'app'), 'Falta variable app en src.main'"

          ExecStart=/opt/gsms/venv/bin/uvicorn src.main:app --host 0.0.0.0 --port 8000 --proxy-headers

          Restart=always
          RestartSec=3
          StandardOutput=journal
          StandardError=journal

          [Install]
          WantedBy=multi-user.target
          EOFU

          read -r -d '' ENVCONF <<'EOFE'
          APP_ENV=prod
          # GSMS_DB_URL=postgresql+psycopg2://user:pass@host:5432/gsms
          EOFE

          # En vez de pelear con quoting dentro de --parameters, armamos un commands.json limpio
          tmpdir="$(mktemp -d)"
          cat > "${tmpdir}/commands.sh" <<'EOSH'
          set -euo pipefail
          id -u gsms >/dev/null 2>&1 || sudo useradd --system --home /opt/gsms --shell /usr/sbin/nologin gsms
          sudo install -d -m 0755 /opt/gsms/app /etc/systemd/system/gsms-web.service.d
          sudo chown -R gsms:gsms /opt/gsms || true

          cat > /tmp/gsms-web.service.b64 <<'EOB1'
          __B64_UNIT__
          EOB1
          cat > /tmp/gsms-web.env.b64 <<'EOB2'
          __B64_ENV__
          EOB2

          base64 -d /tmp/gsms-web.service.b64 | sudo tee /etc/systemd/system/gsms-web.service >/dev/null
          base64 -d /tmp/gsms-web.env.b64    | sudo tee /etc/systemd/system/gsms-web.service.d/env.conf >/dev/null
          sudo chown root:root /etc/systemd/system/gsms-web.service /etc/systemd/system/gsms-web.service.d/env.conf
          sudo chmod 644 /etc/systemd/system/gsms-web.service
          sudo chmod 640 /etc/systemd/system/gsms-web.service.d/env.conf
          sudo systemctl daemon-reload
          sudo systemctl enable gsms-web.service

          if ! sudo systemctl restart gsms-web.service; then
            echo '--- systemctl status ---'
            sudo systemctl --no-pager --full status gsms-web.service || true
            echo '--- journalctl tail ---'
            sudo journalctl -u gsms-web --no-pager -n 120 || true
            exit 1
          fi
          sudo systemctl --no-pager --full status gsms-web.service | tail -n 80 || true
          EOSH

          # Inyectamos los blobs en el script remoto
          B64_UNIT="$(printf "%s" "$UNIT" | base64 -w0)"
          B64_ENV="$(printf "%s" "$ENVCONF" | base64 -w0)"
          sed -i "s|__B64_UNIT__|${B64_UNIT}|g" "${tmpdir}/commands.sh"
          sed -i "s|__B64_ENV__|${B64_ENV}|g"   "${tmpdir}/commands.sh"

          # Empaquetamos el script en una sola línea para SSM
          ONE_LINER="$(awk '{printf "%s\\n", $0}' "${tmpdir}/commands.sh")"
          rm -rf "${tmpdir}"

          # Llamada a SSM con manejo explícito de errores (para ver el motivo si falla)
          set -x
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${IDS[@]}" \
            --document-name "AWS-RunShellScript" \
            --comment "Instalar/actualizar gsms-web.service a 0.0.0.0:8000" \
            --parameters "commands=${ONE_LINER}" \
            --query "Command.CommandId" --output text) || {
              echo "ERROR al enviar send-command (arriba debe verse el motivo del CLI)."
              exit 1
            }
          set +x

          echo "CommandId: ${CMD_ID}"



      - name: Instalar unit systemd gsms-release-sync.service
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"

          # Construimos el unit y lo convertimos a una sola línea base64
          B64_UNIT=$(base64 -w0 <<'EOF_UNIT'
          [Unit]
          Description=GSMS Release Sync (pull latest from S3 using SSM param)
          Wants=network-online.target
          After=network-online.target

          [Service]
          Type=oneshot
          Environment="AWS_DEFAULT_REGION=us-east-1"
          ExecStart=/bin/bash -lc '\
            set -euo pipefail; \
            URI=$(aws ssm get-parameter --name /gsms/prod/app/package_url --query "Parameter.Value" --output text); \
            echo "[gsms-release-sync] Deploying $URI"; \
            /usr/local/bin/deploy_from_s3.sh "$URI" \
          '

          [Install]
          WantedBy=multi-user.target
          EOF_UNIT
          )

          CMD_ID=$(aws ssm send-command \
            --instance-ids "${IDS[@]}" \
            --document-name "AWS-RunShellScript" \
            --comment "Instalar unit gsms-release-sync" \
            --parameters "{\"commands\":[
              \"set -e\",
              \"echo '${B64_UNIT}' | base64 -d | sudo tee /etc/systemd/system/gsms-release-sync.service >/dev/null\",
              \"sudo chmod 644 /etc/systemd/system/gsms-release-sync.service\",
              \"sudo systemctl daemon-reload\",
              \"sudo systemctl enable gsms-release-sync.service\"
            ]}" \
            --query "Command.CommandId" --output text)

          echo "CommandId: ${CMD_ID}"

      - name: Preflight S3 desde EC2 (permisos/alcance)
        shell: bash
        run: |
          set -euo pipefail
          RELEASE_URI="${{ steps.meta.outputs.release_uri }}"
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${IDS[@]}" \
            --document-name "AWS-RunShellScript" \
            --comment "GSMS Preflight S3 read" \
            --parameters "{\"commands\":[
              \"set -e\",
              \"echo Testing: ${RELEASE_URI}\",
              \"aws s3 ls '${RELEASE_URI}/' --recursive > /tmp/ls.out 2>/tmp/ls.err || true\",
              \"echo '--- ls.rc:' $?\",
              \"echo '--- ls.err:'; sed -n '1,50p' /tmp/ls.err || true\",
              \"echo '--- ls.out (head):'; sed -n '1,10p' /tmp/ls.out || true\"
            ]}" \
            --query "Command.CommandId" --output text)

          for id in "${IDS[@]}"; do
            for i in {1..20}; do
              STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" --query "Status" --output text || echo unknown)
              [[ "$STATUS" == "Success" || "$STATUS" == "Cancelled" || "$STATUS" == "Failed" || "$STATUS" == "TimedOut" ]] && break
              sleep 3
            done
            echo "---- Resultado en $id ----"
            aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" --query "{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}" --output text || true
            echo "---------------------------"
          done

      - name: Desplegar release en EC2 vía SSM
        id: deploy
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"
          RELEASE_URI="${{ steps.meta.outputs.release_uri }}"
          echo "Enviando deploy a: ${IDS[*]}"

          CMD_ID=$(aws ssm send-command \
            --instance-ids "${IDS[@]}" \
            --document-name "AWS-RunShellScript" \
            --comment "GSMS Deploy ${GITHUB_SHA}" \
            --parameters "{\"commands\":[
              \"set -e\",
              \"echo 'Deploying ${RELEASE_URI}'\",
              \"/usr/local/bin/deploy_from_s3.sh ${RELEASE_URI}\"
            ]}" \
            --query "Command.CommandId" --output text)

          echo "cmd_id=${CMD_ID}" >> $GITHUB_OUTPUT
          echo "CommandId: ${CMD_ID}"

      - name: Esperar y verificar despliegue SSM
        shell: bash
        run: |
          set -euo pipefail
          CMD_ID="${{ steps.deploy.outputs.cmd_id }}"
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"
          FAIL=0

          for id in "${IDS[@]}"; do
            echo "Esperando resultado en $id ..."
            for i in {1..40}; do
              OUT=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" || true)
              STATUS=$(echo "$OUT" | jq -r '.Status // "Unknown"')
              if [[ "$STATUS" == "Success" ]]; then
                echo "OK $id"
                break
              fi
              if [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
                echo "Fallo en $id, status=$STATUS"
                echo "$OUT"
                FAIL=1
                break
              fi
              sleep 6
            done
          done

          if [[ $FAIL -ne 0 ]]; then
            echo "ERROR: Alguna instancia falló en el despliegue."
            exit 1
          fi

      # ----------------------- REINICIO -----------------------
      - name: Reboot instances (optional)
        if: ${{ env.REBOOT_AFTER_DEPLOY == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"
          echo "Reiniciando: ${IDS[*]}"
          aws ec2 reboot-instances --instance-ids "${IDS[@]}"

      - name: Wait for instances to pass status checks
        if: ${{ env.REBOOT_AFTER_DEPLOY == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"
          echo "Esperando a que las instancias pasen instance-status-ok..."
          aws ec2 wait instance-status-ok --instance-ids "${IDS[@]}"
          echo "Checks OK"

      - name: Start/attach & monitor ASG Instance Refresh (idempotent)
        shell: bash
        env:
          ASG_CANCEL_INPROGRESS: "false"
        run: |
          set -euo pipefail

          ASG="${{ env.ASG_NAME }}"
          if [[ -z "$ASG" ]]; then
            echo "No se definió ASG_NAME; se omite Instance Refresh."
            exit 0
          fi

          echo "Consultando estado de Instance Refresh en ASG: $ASG"
          read -r CUR_ID CUR_STATUS CUR_REASON CUR_START <<<"$(
            aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "$ASG" \
              --max-records 1 \
              --query 'InstanceRefreshes[0].[InstanceRefreshId,Status,StatusReason,StartTime]' \
              --output text || true
          )"

          if [[ -n "${CUR_ID:-}" && "${CUR_STATUS:-}" =~ ^(Pending|InProgress)$ ]]; then
            echo "Hay un Instance Refresh en curso:"
            echo "  ID:      $CUR_ID"
            echo "  Status:  $CUR_STATUS"
            echo "  Reason:  ${CUR_REASON:-<none>}"
            echo "  Started: ${CUR_START:-<unknown>}"

            if [[ "${ASG_CANCEL_INPROGRESS}" == "true" ]]; then
              echo "ASG_CANCEL_INPROGRESS=true -> cancelando refresh en curso..."
              aws autoscaling cancel-instance-refresh --auto-scaling-group-name "$ASG" >/dev/null
              for i in {1..20}; do
                S=$(aws autoscaling describe-instance-refreshes \
                      --auto-scaling-group-name "$ASG" \
                      --max-records 1 \
                      --query 'InstanceRefreshes[0].Status' \
                      --output text || echo "Unknown")
                [[ "$S" == "Cancelled" || "$S" == "Successful" || "$S" == "Failed" ]] && break
                sleep 3
              done
              echo "Iniciando nuevo Instance Refresh..."
              REFRESH_ID=$(aws autoscaling start-instance-refresh \
                --auto-scaling-group-name "$ASG" \
                --strategy Rolling \
                --preferences '{"MinHealthyPercentage":100,"InstanceWarmup":120}' \
                --query 'InstanceRefreshId' --output text)
            else
              echo "Enganchando al refresh existente (no se inicia uno nuevo)."
              REFRESH_ID="$CUR_ID"
            fi
          else
            echo "No hay refresh en curso. Iniciando uno nuevo..."
            REFRESH_ID=$(aws autoscaling start-instance-refresh \
              --auto-scaling-group-name "$ASG" \
              --strategy Rolling \
              --preferences '{"MinHealthyPercentage":100,"InstanceWarmup":120}' \
              --query 'InstanceRefreshId' --output text)
          fi

          echo "Monitoreando Instance Refresh: $REFRESH_ID"
          for i in {1..60}; do
            DESC=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "$ASG" \
              --instance-refresh-ids "$REFRESH_ID" \
              --query 'InstanceRefreshes[0].[Status,StatusReason,PercentageComplete]' \
              --output text || echo "")
            STATUS=$(echo "$DESC" | awk '{print $1}')
            REASON=$(echo "$DESC" | cut -d' ' -f2- | sed -e 's/[[:space:]]*$//' || true)
            PCT=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "$ASG" \
              --instance-refresh-ids "$REFRESH_ID" \
              --query 'InstanceRefreshes[0].PercentageComplete' --output text 2>/dev/null || echo "0")

            echo "  [$i] Status=$STATUS  Progress=${PCT:-0}%  Reason=${REASON:-<none>}"

            if [[ "$STATUS" == "Successful" ]]; then
              echo "Instance Refresh completado."
              exit 0
            elif [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" ]]; then
              echo "::error::Instance Refresh terminó con estado $STATUS. Reason: ${REASON:-n/a}"
              exit 1
            fi
            sleep 30
          done

          echo "::error::Timeout esperando a que termine el Instance Refresh ($REFRESH_ID)."
          exit 1

      - name: Post-reboot healthcheck via SSM
        if: ${{ env.REBOOT_AFTER_DEPLOY == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -ra IDS <<< "${{ steps.targets.outputs.instance_ids }}"
          echo "Ejecutando healthcheck /health en cada instancia..."
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${IDS[@]}" \
            --document-name "AWS-RunShellScript" \
            --comment "GSMS post-reboot healthcheck" \
            --parameters "{\"commands\":[
              \"bash -lc 'set -euo pipefail;
                command -v curl >/dev/null 2>&1 || (which dnf >/dev/null && sudo dnf -y install curl || which yum >/dev/null && sudo yum -y install curl || true);
                for i in $(seq 1 40); do
                  if curl -fsS --max-time 3 http://127.0.0.1:8000/health >/dev/null; then
                    echo HEALTH_OK; exit 0;
                  fi;
                  systemctl is-active --quiet gsms-web && echo \"[info] gsms-web=active, esperando app\" || echo \"[warn] gsms-web no activo\";
                  sleep 5;
                done;
                echo HEALTHCHECK_FAILED;
                echo '--- systemctl status gsms-web (tail) ---'; systemctl --no-pager --full status gsms-web | tail -n 80 || true;
                echo '--- journalctl gsms-web (tail) ---'; journalctl -u gsms-web --no-pager -n 120 || true;
                exit 1' \"
            ]}" \
            --query "Command.CommandId" --output text)

          FAIL=0
          for id in "${IDS[@]}"; do
            echo "Esperando resultado en $id ..."
            for i in {1..60}; do
              STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" --query "Status" --output text || echo "Unknown")
              if [[ "$STATUS" == "Success" ]]; then
                echo "Health OK en $id"
                break
              fi
              if [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
                echo "Health FAILED en $id"
                aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$id" \
                  --query "{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}" --output text || true
                FAIL=1
                break
              fi
              sleep 5
            done
          done
          [[ $FAIL -eq 0 ]]


      - name: Fin
        run: echo "Despliegue completado correctamente en todas las instancias."
